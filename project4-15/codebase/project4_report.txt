1. Basic information
Team number (e.g., 01) : 15
#1 Student ID : 1403225
#1 Student Name : Morgan Grant
#2 Student ID : 1402341
#2 Student Name : Daniel Thurau
#3 Student ID : 1411983
#3 Student Name : Preston Fraser


2. Catalog information about Index
- Show what catalog information you store for an index. 

	Added a table to the catalog, Indexes, which holds the name of the table
	the index is on, the attribute of the table that index is on, and filename
	containing the index of each index.

3. Index Nested Loop Join
- Describe how your Index Nested Loop Join works.

	

4. Implementation Detail
- Have you added your own source file (.cc or .h)?

	We did not provide any new files for our implementation.

- Have you implemented any optional features? Then, describe them here.

	As part of our implementation for the INLJoin iterator, we created a new
	iterator class CartProd (short for "Cartesian Product"), which was
	basically leveraged for its getNextTuple() function. CartProd assumes all
	of the same fields as the INLJoin iterator that calls it in its constructor
	except for the Condition, which it does not need to use.

    Iterator *leftIn:		    	The "outer" table of the join. 
    IndexScan *rightIn:				The "inner" table of the join.
    vector<Attribute> leftAttrs:	Attributes of "outer" table.
    vector<Attribute> rightAttrs:	Attributes of "outer" table.
    unsigned leftInputTupleSize:	The size of all tuples in the "outer".
    unsigned rightInputTupleSize:	The size of all tuples in the "inner".

	RC CartProd::getNextTuple(void *data):
		This function scans through all tuples in the outer table with rightIn
		for every tuple of the inner table with leftIn, resetting the rightIn
		iterator every time the inner table is completely scanned. When leftIn
		reaches the last tuple, there are no more tuples in the Cartesian
		Product to get.
		This function reads the data from the outer table into leftData, the
		data from the inner table into rightData and then reads the
		concatenation of leftData + rightData into the data parameter, a tuple
		from the Cartesian product.

	RC CartProd::getAttributes(vector<Attribute> &attrs) const:
		This function reads leftAttrs into attrs, and then rightAttrs into
		attrs right after, providing the complete set of attributes for the
		cartesian product.

- Other implementation details:

	RelationManager = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

	Changes to existing functions:
	- createCatalog() now creates the Indexes table.
	- deleteCatalog() deletes the Indexes table.
	- deleteTable() deletes all of the indexes on the table being deleted.
	- insertTuple() adds the tuple to every relevant index on the table.
	- deleteTuple() removes the tuple from every relevant index on thetable.

	Implemented and new functions:
	RC createIndex(const string &tableName, const string &attributeName):
		Creates an index through the IndexManager and adds it to the Indexes
		table in the catalog.

	RC destroyIndex(const string &tableName, const string &attributeName):
		Destroys the index through the IndexManager and updates the Indexes
		table in the catalog accordingly.

	RC indexScan(const string &tableName, const string &attributeName,
	  const void *lowKey, const void *highKey, bool lowKeyInclusive,
	  bool highKeyInclusive, RM_IndexScanIterator &rm_IndexScanIterator):
		Opens the file using the IndexManager then obtains the attribute for
		the record using attributeName in getAttributes(). Lastly, it scans
		using rm_IndexScanIterator.

	RC getIndexFilename(const string &tableName, const string &attributeName,
	  string &fileName, RID &rid):
	  	Obtains the name of the file containing the index by scanning through
	  	all indexes created for tableName contained in the Indexes table. This
	  	is done until we find a match on the attribute the index was created
	  	on. When the match is established, we obtain the name from the index
	  	and set fileName to that value. If no match was found, a corresponding
	  	RC is returned.

	RC updateIndexes(const string &tableName, const void *data,
	  const RID &rid):
	  	This function is called whenever a tuple is being inserted into the
	  	table that this index is on. It extracts the matching attribute from
	  	the tuple and enters rid and key into the respective index.

	void getAttrFromTuple(const vector<Attribute> attrs, int index,
	  const void *tuple, void *&data):
	  	Extracts the desired attribute at index from tuple and reads it into
	  	data.

	RM_IndexScanIterator = = = = = = = = = = = = = = = = = = = = = = = = = = =

	IX_ScanIterator ix_scanIterator:	Iterator for the index.
	IXFileHandle ixfileHandle:			File handle of the index being scanned

	RC getNextEntry(RID &rid, void *key):
		Returns the result of getNextEntry(rid, key) under ix_scaniterator.

	RC close():
		Closes the ix_scanIterator as well as the ixfileFileHandle.

	Filter = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =



	Project = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =



	INLJoin = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =



	

5. Other (optional)
- Freely use this section to tell us about things that are related to the
  project 4, but not related to the other sections (optional)

