1. Basic information
Team number (e.g., 01) : 15
#1 Student ID : 1403225
#1 Student Name : Morgan Grant
#2 Student ID : 1402341
#2 Student Name : Daniel Thurau
#3 Student ID : 1411983
#3 Student Name : Preston Fraser


2. Catalog information about Index
- Show what catalog information you store for an index. 

	Added a table to the catalog, Indexes, which holds the name of the table
	the index is on, the attribute of the table that index is on, and filename
	containing the index of each index.

3. Index Nested Loop Join
- Describe how your Index Nested Loop Join works.

	

4. Implementation Detail
- Have you added your own source file (.cc or .h)?

	We did not provide any new files for our implementation.

- Have you implemented any optional features? Then, describe them here.

	As part of our implementation for the INLJoin iterator, we created a new
	iterator class CartProd (short for "Cartesian Product"), which was
	basically leveraged for its getNextTuple() function. CartProd assumes all
	of the same fields as the INLJoin iterator that calls it in its constructor
	except for the Condition, which it does not need to use.

    Iterator *leftIn:		    	The "outer" table of the join. 
    IndexScan *rightIn:				The "inner" table of the join.
    vector<Attribute> leftAttrs:	The 
    vector<Attribute> rightAttrs:
    unsigned leftInputTupleSize:
    unsigned rightInputTupleSize:

	RC CartProd::getNextTuple(void *data):
		This function scans through all tuples in the outer table with rightIn
		for every tuple of the inner table with leftIn, resetting the rightIn
		iterator every time the inner table is completely scanned. When leftIn
		reaches the last tuple, there are no more tuples in the Cartesian
		Product to get.
		This function reads the data from the outer table into leftData, the
		data from the inner table into rightData and then reads the
		concatenation of leftData + rightData into the data parameter, a tuple
		from the Cartesian product.

	RC CartProd::getAttributes(vector<Attribute> &attrs) const:
		This function reads leftAttrs into attrs, and then rightAttrs into
		attrs right after, providing the complete set of attributes for the
		cartesian product.

- Other implementation details:

	Catalog = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

	createCatalog() now creates the Indexes table, deleteCatalog() deletes
	the Indexes table. deleteTable() deletes all of the indexes on the table
	being deleted. insertTuple() adds the tuple to every relevant index on the
	table. deleteTuple() removes the tuple from every relevant index on the
	table.

	updateIndexes() is the function used in insertTuple() to perform the update
	on the relevant indexes. createIndex() creates an index through the Index
	Manager and adds it to the Indexes catalog.	destroyIndex() destroys the
	index through the Index Manager and updates the Indexes catalog
	accordingly.

	RM_IndexScanIterator = = = = = = = = = = = = = = = = = = = = = = = = = = =

	RM_IndexScanIterator just implements the corresponding functions from the
	IX_ScanIterator.

	Filter = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    class Filter : public Iterator() is the implememntation of an iterator class to add the 
    option of filtering to the querying engine. It will take tuples passed by
    previous iterators and apply a conditional operator to specified attributes
    and return data that passes the condition.

    Iterator *input:                An input iterator that provides entries to the filter
    vector<string> attrNames:       A vector of attribute names to be provided to iterators using filter
    vector<Attribute> inputAttrs:   The set of aattributes provided by the input iterator
    Condition cond:                 The condition struct provides the conditional values needed to apply the filter.
    unsigned index:                 The index of the attribute the filter is being applied to.
    unsigned inputTupleSize:        The size of the tuple being provided by the input iterator.

    RC getNextTuple(void *data)
        getNextTuple will call the api of the input iterator for the next entry in 
        the list and apply one of the filter functions on the data. This functions is 
        responsible for checking correctness of the condition input, the data being 
        passed in from the input iterator, and formatting the attribute of the data
        being filtered.

    bool filterData(<uint32_t/float/void*> record<Type>, CompOp compOp, const <uint32_t/float/void*> value)
        filterData takes a type of data and applies the compop and returns the boolean
        value from applying compop on record and value. If the attributes are varchar's, 
        filterData() converts the void* to null terminated strings and uses strcmp to
        determine boolean.

    void getAttributes(vector<Attribute> &attrs) const
        getAttributes provides the list of attributes used after the filter is applied. 
        For the case of filter, the attributes always remain the same and the vector is 
        formatted and returned.


	Project = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    class Project : public Iterator() is the implememntation of an iterator class to add the 
    option of projection to the querying engine. It will take tuples passed by
    previous iterators and project a vector of string names of attributes to remain, and 
    return this updated tuple.

    Iterator *input:                An input iterator that provides entries to the projection
    vector<string> attrNames:       A vector of attribute names to be provided to iterators using projection
    vector<Attribute> inputAttrs:   The set of aattributes provided by the input iterator
    unsigned inputTupleSize:        The size of the tuple being provided by the input iterator.

    RC getNextTuple(void *data)
        getNextTuple will call the api of the input iterator for the next entry in 
        the list and pass the needed arguments to projectAttributes to remove un-needed 
        attributes. This data will be returned to getNextTuple which will serve this 
        newly projected data to the caller of the function.

    void getAttributes(vector<Attribute> &attrs) const
        getAttributes returns the vector of attributes remaining after the attributes are 
        removed by the projection.
    
    RC projectAttributes(void *origData, void *newData)
        projectAttributes will take in origData from getNextTuple and copy segments of data 
        that are needed post projection, per data type. It will also update the nullIndicator at the 
        beginning of the tuple. 
    

	INLJoin = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =



	

5. Other (optional)
- Freely use this section to tell us about things that are related to the
  project 4, but not related to the other sections (optional)

